// ===================================================================
//
// (c) Paul Alan Freshney 2014
// www.freshney.org :: paul@freshney.org :: maximumoctopus.com
//
// Please do not redistribute the source code!
//
//   Started: October 26th 2014
//  Modified: November 1st 2014
//
//  2373
//
// ===================================================================

unit thematrix;

interface

uses ExtCtrls, classes, controls, types, sysutils, graphics, math;

const
  _MaxWidth           = 128; // 0-127
  _MaxHeight          = 128; // 0-127
  _MaxAnimBufferFrame = 500;

  modeFlipAll         = 0;
  modeMirrorAll       = 1;
  modeInvertAll       = 2;
  modeGradientAll     = 3;

  modeFlip            = 0;
  modeMirror          = 1;
  modeInvert          = 2;

  modeScrollLeft      = 0;
  modeScrollRight     = 1;
  modeScrollUp        = 2;
  modeScrollDown      = 3;

  modeRotateCW        = 0;
  modeRotateACW       = 1;

  drawModeNone        = 0;
  drawModeFilledBox   = 1;
  drawModeEmptyBox    = 2;
  drawModeLine        = 3;
  drawModeFont        = 4;
  drawModeEmptyCircle = 5;
  drawModeRandom      = 7;
  drawModeCopy        = 10; // active when user is selecting point 1 and point 2 of the capture square
  drawModePaste       = 11; // active when user is pasting copied section

  powers    : array[0..63] of int64 = (1,2,4,8,16,32,64,128,
                                       256,512,1024,2048,4096,8192,16384,32768,
                                       65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,
                                       16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648,
                                       4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888,
                                       1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328,
                                       281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984, 36028797018963968,
                                       72057594037927936, 144115188075855872, 288230376151711744, 576460752303423488, 1152921504606846976, 2305843009213693952, 4611686018427387904, 9223372036854775808);

type
  TImportData = record
                  Source          : integer;
                  SourceLSB       : integer;
                  SourceDirection : integer;
                  PadMode         : integer;
                  HexFormat       : integer;
                  HexOutput       : integer;
                  Brackets        : integer;
                  MatrixType      : integer;
                  NewWidth        : integer;
                  NewHeight       : integer;
                  NewFrames       : integer;
                  MaxFrames       : integer;
                  ASCIIIndex      : integer;
                  FontMode        : boolean;
                end;

  TUndoStructure = record
                     mode : integer; // 0 replace current frame, 1 = undo rotate
                     param1, param2 : integer;
                   end;

  TMouseOverEvent = procedure(const x,y : integer) of object;

  TTheMatrix = class
  private
    PaintBox         : TPaintBox;
    FOnChange        : TNotifyEvent;
    FOnMouseOver     : TMouseOverEvent;

    function LoadDataParameterType(s : string): integer;
  public
    UndoData         : TUndoStructure;

    fCurrentFrame    : integer;
    fLightBox        : integer;

    MatrixComment    : string;

    MatrixWidth      : integer;
    MatrixHeight     : integer;
    MatrixType       : integer;
    MatrixGradient   : integer; // 0 = off, 1 = on
    MatrixGrid       : boolean;
    MatrixPixelSize  : integer;
    MatrixPixelSizeZ : integer;
    MatrixPixelShape : integer; // 0 = square, 1 = cirle
    MatrixBrushSize  : integer; // 0 = 1 pixel, 1 = 2x2;
    LastX, LastY     : integer;

    AnimPlaying      : boolean;

    MatrixCopyX      : byte;
    MatrixCopyY      : byte;

    SelectionLMB     : integer;
    SelectionMMB     : integer;
    SelectionRMB     : integer;

    DrawMode         : integer;
    DrawPoint        : integer;
    DrawColour       : integer;
    DrawCoords       : array[0..1] of TPoint;

    LEDColoursSingle : array[0..5] of integer;
    LEDColoursBi     : array[0..5] of integer;
    LEDColours       : array[0..5] of integer; // currently being displayed
    LEDFont          : array[0..189] of string;
    LEDFontSize      : integer;

    Matrix           : array[0.._MaxAnimBufferFrame+11, 0.._MaxWidth, 0.._MaxHeight] of integer;
    MatrixBackup     : array[0.._MaxWidth, 0.._MaxHeight] of byte;
    MatrixCopy       : array[0.._MaxWidth, 0.._MaxHeight] of byte;

    MatrixGradientI  : array[0.._MaxHeight] of integer;

    constructor Create(AOwner: TComponent; Zig : TWinControl);
    destructor  Destroy; Override;
    procedure   NewMatrix(mtype, top, left, width, height, pixelsize, pixelshape : integer; grid, readonly, clearall : boolean);

    procedure   PaintBoxUpdate(Sender: TObject);

    procedure   ChangePixelSize(newpixelsize : integer);
    procedure   ChangePixelShape(newpixelshape : integer);
    procedure   ChangePixelBrush(newbrushsize : integer);
    procedure   ChangeMatrixType(newmatrixtype : integer);
    procedure   SetMouseButtonColours(lmb, mmb, rmb : integer);

    procedure   BackupMatrix(matrixindex : integer);
    procedure   ClearCurrentFrame;
    procedure   ClearFrame(frame : integer);
    procedure   ClearAllFrames;
    procedure   PerformEffectOnCurrentFrame(mode : integer);
    procedure   PerformEffectOnAllFrames(mode : integer);
    procedure   PerformScrollOnCurrentFrame(mode : integer);
    procedure   RotateCurrentFrame(mode : integer);
    procedure   RotateFrame(newangle : real; toframe : integer);

    procedure   DrawWithBrush(index, x, y : integer);
    procedure   ClickPixel(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure   Shape1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure   Shape1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure   Shape1MouseUpBiColour(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure   ClickPixelBiColour(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure   Shape1MouseMoveBiColour(Sender: TObject; Shift: TShiftState; X, Y: Integer);

    procedure   CopyCurrentFrame;

    procedure   InsertBlankFrameAt(frameinsert, maxframes : integer);
    procedure   InsertCopyFrameAt(frameinsert, maxframes : integer);
    procedure   AddFrameMultiple(framecount, framecurrent, framemax : integer);

    procedure   DeleteFrame(frame, framemax : integer);

    procedure   ChangeCurrentFrame(frame : integer);
    procedure   ChangeLightBox(lb : integer);
    procedure   ChangeGrid(grid : boolean);

    procedure   CopyShape;
    procedure   UpdateDrawTool(setx, sety, setcolour : integer);
    procedure   DrawShape(realtime : boolean; colour : integer);

    procedure   DrawFontCharacter(asciicode, frameid : integer);
    procedure   DeleteFontCharacter(frameid : integer);
    procedure   LoadFont(filename : string);

    procedure   ImportRowData(imhex : boolean; sourcedirection, sourcelsb : integer; s : string);
    procedure   ImportColumnData(imhex : boolean; sourcedirection, sourcelsb : integer; s : string);
    function    ImportLEDMatrixDataSingleFrame(fn : string): TImportData;
    function    ImportFromBMP(fn : string; fcount, fwidth, fheight : integer): TImportData;

    procedure   SaveAnimation(filename : string; ted : TImportData);
    procedure   SaveFont(filename : string; ted : TImportData);
    procedure   SaveAsFont(filename : string);
    procedure   SaveSingleFrame(filename : string; ted : TImportData; frame : integer);

    procedure   LoadGradient(filename : string);

    function    LoadLEDMatrixData(fn : widestring): TImportData;

    procedure   CopyToUserBuffer(slot : integer);
    procedure   RestoreFromUserBuffer(slot : integer);
    procedure   CopyFromPrevious(toframe : integer);

    procedure   Undo;        
  published
    Property    CurrentFrame : integer Read fCurrentFrame Write ChangeCurrentFrame;
    Property    LightBox     : integer Read fLightBox     Write ChangeLightBox;

    property    OnChange     : TNotifyEvent read FOnChange write FOnChange;
    property    OnMouseOver  : TMouseOverEvent read FOnMouseOver write FOnMouseOver;
  protected
    procedure   MatrixChange; dynamic;
    procedure   MouseOver; dynamic;
  end;

implementation

uses dialogs;

constructor TTheMatrix.Create(AOwner: TComponent; Zig : TWinControl);
 begin
  PaintBox         :=TPaintBox.Create(AOwner);
  PaintBox.Parent  :=Zig;
  PaintBox.OnPaint :=PaintBoxUpdate;

  fCurrentFrame    := 1;
  fLightBox        := 0;

  DrawMode         := drawModeNone;
  DrawPoint        := 0;
  DrawColour       := 0;
  DrawCoords[0].X  := -1;
  DrawCoords[0].Y  := -1;

  MatrixGradient   := 0;

  MatrixBrushSize  := 0;

  UndoData.mode    :=-1;

  MatrixComment    := '';

  // ===========================================================================

  with PaintBox do begin
    OnMouseDown :=ClickPixel;
    OnMouseMove :=Shape1MouseMove;
    OnMouseUp   :=Shape1MouseUp;
  end;

  // ===========================================================================

  ClearAllFrames;
end;

destructor TTheMatrix.Destroy;
 begin
  PaintBox.Free;

  inherited Destroy;
end;

procedure TTheMatrix.MatrixChange;
 begin
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TTheMatrix.MouseOver;
 begin
//  if Assigned(FOnMouseOver) then
//    FOnMouseOver();
end;

procedure TTheMatrix.PaintBoxUpdate(Sender: TObject);
 var
  x, y : integer;

 begin
  for x:=0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      case Matrix[fCurrentFrame, x, y] of
        0 : begin
              if (fLightbox = 1) and (fCurrentFrame<>1) then begin
                if Matrix[fCurrentFrame-1, x, y] = 1 then
                  PaintBox.Canvas.Brush.Color := LEDColours[5]
                else
                  PaintBox.Canvas.Brush.Color := LEDColours[0];
              end
              else begin
                PaintBox.Canvas.Brush.Color := LEDColours[0];
              end;
            end;
        1 : PaintBox.Canvas.Brush.Color := LEDColours[1];
        2 : PaintBox.Canvas.Brush.Color := LEDColours[2];
        3 : PaintBox.Canvas.Brush.Color := LEDColours[3];
      end;

      case MatrixPixelShape of
        0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                         (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
        1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                   (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
      end;
    end;
  end;

  // ===========================================================================
  // ===========================================================================

  if DrawMode<>drawModeNone then begin
    if DrawCoords[0].X <> -1 then begin
      PaintBox.Canvas.Brush.Color := LEDColours[DrawColour];
      DrawShape(True, 1);

      // =======================================================================

      PaintBox.Canvas.Brush.Color := LEDColours[4];

      case MatrixPixelShape of
        0 : PaintBox.Canvas.FillRect(Rect(DrawCoords[0].X*MatrixPixelSize, DrawCoords[0].Y*MatrixPixelSize,
                                   (DrawCoords[0].X*MatrixPixelSize)+MatrixPixelSizeZ, (DrawCoords[0].Y*MatrixPixelSize)+MatrixPixelSizeZ));
        1 : PaintBox.Canvas.Ellipse(DrawCoords[0].X*MatrixPixelSize, DrawCoords[0].Y*MatrixPixelSize,
                                   (DrawCoords[0].X*MatrixPixelSize)+MatrixPixelSizeZ, (DrawCoords[0].Y*MatrixPixelSize)+MatrixPixelSizeZ);
      end;
    end;
  end;

  // ===========================================================================
  // ===========================================================================

  if MatrixCopyX<>0 then begin
    for x:=0 to MatrixCopyX do begin
      for y:=0 to MatrixCopyY do begin
        if (x+lastx>=0) and (x+lastx<=MatrixWidth) and
          (y+lasty>=0) and (y+lasty<=MatrixHeight) then begin

           PaintBox.Canvas.Brush.Color := LEDColours[MatrixCopy[x, y]];

           case MatrixPixelShape of
             0 : PaintBox.Canvas.FillRect(Rect((x+lastx)*MatrixPixelSize, (y+lasty)*MatrixPixelSize,
                                        ((x+lastx)*MatrixPixelSize)+MatrixPixelSizeZ, ((y+lasty)*MatrixPixelSize)+MatrixPixelSizeZ));
             1 : PaintBox.Canvas.Ellipse((x+lastx)*MatrixPixelSize, (y+lasty)*MatrixPixelSize,
                                        ((x+lastx)*MatrixPixelSize)+MatrixPixelSizeZ, ((y+lasty)*MatrixPixelSize)+MatrixPixelSizeZ);
           end;
        end;
      end;
    end;
  end;
end;

procedure TTheMatrix.ClearAllFrames;
 var
  x,y,z : integer;

 begin
  for z:=0 to _MaxAnimBufferFrame do begin
    for x:=0 to _MaxWidth do begin
      for y:=0 to _MaxHeight do begin
        Matrix[z, x, y] := 0;
      end;
    end;
  end;

  MatrixChange;
end;

procedure TTheMatrix.SetMouseButtonColours(lmb, mmb, rmb : integer);
 begin
  SelectionLMB := lmb;
  SelectionMMB := mmb;
  SelectionRMB := rmb;
end;

procedure TTheMatrix.NewMatrix(mtype, top, left, width, height, pixelsize, pixelshape : integer; grid, readonly, clearall : boolean);
 begin
  fCurrentFrame    := 1;
  fLightBox        := 0;

  AnimPlaying      := False;

  MatrixCopyX      := 0;
  MatrixCopyY      := 0;

  DrawMode         := drawModeNone;
  DrawPoint        := 0;
  DrawColour       := 0;  
  DrawCoords[0].X  := -1;
  DrawCoords[0].Y  := -1;

  LastX            := -1;
  LastY            := -1;

  PaintBox.Top     := Top;
  PaintBox.Left    := Left;
  PaintBox.Width   := (Width+1)*pixelsize;
  PaintBox.Height  := (Height+1)*pixelsize;

  MatrixWidth      := Width;
  MatrixHeight     := Height;
  MatrixType       := mtype;
  MatrixGradient   := 0;
  MatrixPixelShape := pixelshape;
  MatrixPixelSize  := PixelSize;

  MatrixGrid       := grid;

  if grid then
    MatrixPixelSizeZ := MatrixPixelSize-1
  else
    MatrixPixelSizeZ := MatrixPixelSize;

  UndoData.mode    :=-1;

  // ===========================================================================

  if readonly = False then begin  // stops editing
    case mtype of
      0 : begin
            PaintBox.OnMouseDown :=ClickPixel;
            PaintBox.OnMouseMove :=Shape1MouseMove;
            PaintBox.OnMouseUp   :=Shape1MouseUp;
          end;
      1 : begin
            PaintBox.OnMouseDown :=ClickPixelBiColour;
            PaintBox.OnMouseMove :=Shape1MouseMoveBiColour;
           PaintBox.OnMouseUp    :=Shape1MouseUpBiColour;
          end;
      2 : begin
            PaintBox.OnMouseDown :=ClickPixelBiColour;
            PaintBox.OnMouseMove :=Shape1MouseMoveBiColour;
            PaintBox.OnMouseUp   :=Shape1MouseUpBiColour;
          end;
    end;
  end;

  // ===========================================================================

  if clearall then begin
    ClearAllFrames;

    MatrixComment := '';
  end;

  MatrixChange;
end;

procedure TTheMatrix.ChangePixelSize(newpixelsize : integer);
 begin
  MatrixPixelSize := newpixelsize;

  PaintBox.Width  := (MatrixWidth+1)*MatrixPixelSize;
  PaintBox.Height := (MatrixHeight+1)*MatrixPixelSize;

  if MatrixGrid then
    MatrixPixelSizeZ := MatrixPixelSize-1
  else
    MatrixPixelSizeZ := MatrixPixelSize;  

  PaintBox.Repaint;
end;

procedure TTheMatrix.ChangePixelShape(newpixelshape : integer);
 begin
  MatrixPixelShape := newpixelshape;

  PaintBox.Repaint;
end;

procedure TTheMatrix.ChangePixelBrush(newbrushsize : integer);
 begin
  MatrixBrushSize := newbrushsize;
end;

procedure TTheMatrix.ChangeMatrixType(newmatrixtype : integer);
 var
  MemSlot, x, y : integer;
  
 begin
  if MatrixWidth<>-1 then begin

    MatrixType := newmatrixtype;

    with PaintBox do begin
      case newmatrixtype of
        0 : begin
              OnMouseDown :=ClickPixel;
              OnMouseMove :=Shape1MouseMove;
              OnMouseUp   :=Shape1MouseUp;
            end;
        1 : begin
              OnMouseDown :=ClickPixelBiColour;
              OnMouseMove :=Shape1MouseMoveBiColour;
              OnMouseUp   :=Shape1MouseUpBiColour;
            end;
        2 : begin
              OnMouseDown :=ClickPixelBiColour;
              OnMouseMove :=Shape1MouseMoveBiColour;
              OnMouseUp   :=Shape1MouseUpBiColour;
            end;
      end
    end;
  end;

  // if we're moving to single colour matrix
  // make sure the matrix data fits!
  if newmatrixtype = 0 then begin
    for MemSlot:=1 to _MaxAnimBufferFrame+11 do begin
      for x:=0 to MatrixWidth do begin
        for y:=0 to MatrixHeight do begin
          if Matrix[MemSlot, x, y]>0 then
            Matrix[MemSlot, x, y]:=1;
        end;
      end;
    end;
  end;

  PaintBox.Repaint;
end;

procedure TTheMatrix.DrawWithBrush(index, x, y : integer);
 var
  a,b : integer;

 begin
  case MatrixBrushSize of
    0 : Matrix[fCurrentFrame, x, y] := index;
    1 : begin
          Matrix[fCurrentFrame, x, y]     := index;
          Matrix[fCurrentFrame, x+1, y]   := index;
          Matrix[fCurrentFrame, x, y+1]   := index;
          Matrix[fCurrentFrame, x+1, y+1] := index;
        end;
    2 : begin
          for a:=0 to 2 do begin
            for b:=0 to 2 do begin
              Matrix[fCurrentFrame, x+a, y+b] := index;
            end;
          end;
        end;
  end;
end;

procedure TTheMatrix.ClickPixel(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
 var
  x1, y1, x2, y2 : integer;

 begin
  x1 := Floor(x/MatrixPixelSize);
  y1 := Floor(y/MatrixPixelSize);

  if (x1<0) or (y1<0) then exit;  

  // ===========================================================================

  if ssleft in shift then begin
    case DrawMode of
      drawModeNone  : begin
                        DrawWithBrush(1, x1, y1);

                        LastX := x1;
                        LastY := y1;

                        MatrixChange;
                      end;
      drawModePaste : begin
                        for x2:=0 to MatrixCopyX do begin
                          for y2:=0 to MatrixCopyY do begin
                            if (x2+x1>=0) and (x2+x1<=MatrixWidth) and
                               (y2+y1>=0) and (y2+y1<=MatrixHeight) then begin

                              if MatrixCopy[x2, y2]=1 then begin
                                Matrix[fCurrentFrame, x2+x1, y2+y1] := 1;
                              end
                              else
                                if not(ssShift in shift) then
                                  Matrix[fCurrentFrame, x2+x1, y2+y1] := 0;
                            end;
                          end;
                        end;

                        MatrixChange;
                      end;
    else
      UpdateDrawTool(x1, y1, 1);
    end;
  end
  else if ssRight in Shift then begin
    case DrawMode of
      drawModeNone  : begin
                        DrawWithBrush(0, x1, y1);

                        LastX := x1;
                        LastY := y1;

                        MatrixChange;
                      end;
    else
      UpdateDrawTool(x1, y1, 0);
    end;
  end;

  PaintBox.Repaint;
end;

procedure TTheMatrix.Shape1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
 var
  x1, y1{, x2, y2} : integer;

 begin
  x1 := Floor(x/MatrixPixelSize);
  y1 := Floor(y/MatrixPixelSize);

  if (x1<0) or (y1<0) then exit;

  // ===========================================================================

  if Assigned(FOnMouseOver) then
    FOnMouseOver(x1, y1);

  // ===========================================================================
  // ===========================================================================

  if ssLeft in Shift then begin
    if drawmode=drawModeNone then begin
      if not((LastX=x1) and (LastY=y1)) then begin
        DrawWithBrush(1, x1, y1);
      end;

      LastX := x1;
      LastY := y1;

      MatrixChange;
    end;
  end
  else if ssRight in Shift then begin
    if drawmode=drawModeNone then begin
      if not((LastX=x1) and (LastY=y1)) then begin
        DrawWithBrush(0, x1, y1);
      end;

      LastX := x1;
      LastY := y1;

      MatrixChange;
    end;
  end;

  LastX := x1;
  LastY := y1;

  PaintBox.Repaint;
end;

procedure TTheMatrix.Shape1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
 begin
  {}
end;

procedure TTheMatrix.Shape1MouseUpBiColour(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
 begin
  {}
end;

procedure TTheMatrix.ClickPixelBiColour(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
 var
  x1, y1, x2, y2, i : integer;

 begin
  x1 := Floor(x/MatrixPixelSize);
  y1 := Floor(y/MatrixPixelSize);

  if (x1<0) or (y1<0) then exit;  

  // ===========================================================================

  if ssleft in shift then begin
    if DrawMode<>drawModeNone then begin
      if DrawMode=drawModePaste then begin
        for x2:=0 to MatrixCopyX do begin
          for y2:=0 to MatrixCopyY do begin
            if (x2+x1>=0) and (x2+x1<=MatrixWidth) and
               (y2+y1>=0) and (y2+y1<=MatrixHeight) then begin

            if MatrixCopy[x2, y2]>0 then begin
              Matrix[fCurrentFrame, x2+x1, y2+y1] :=MatrixCopy[x2, y2];
            end
            else
              if not(ssShift in shift) then
                Matrix[fCurrentFrame, x2+x1, y2+y1] :=0;
            end;
          end;
        end;

        MatrixChange;
      end
      else if DrawMode=drawModeRandom then begin
        i:=1+random(3);

        DrawWithBrush(i, x1, y1);
      end
      else begin
        UpdateDrawTool(x1, y1, SelectionLMB);
      end;
    end
    else begin
      if (MatrixGradient = 1) and (MatrixGradientI[y1]<>0) and (SelectionLMB<>0) then begin
        DrawWithBrush(MatrixGradientI[y1], x1, y1);
      end
      else begin
        if Matrix[fCurrentFrame, x1, y1]=0 then begin
          DrawWithBrush(SelectionLMB, x1, y1);
        end
        else begin
          DrawWithBrush(0, x1, y1);
        end;
      end;

      LastX := x1;
      LastY := y1;

      MatrixChange;
    end
  end
  else if ssMiddle in shift then begin
    if DrawMode<>drawModeNone then begin
      UpdateDrawTool(x1, y1, SelectionMMB);
    end
    else begin
      if Matrix[fCurrentFrame, x1, y1]=0 then begin
        DrawWithBrush(SelectionMMB, x1, y1);
      end;

      LastX := x1;
      LastY := y1;

      MatrixChange;
    end;
  end
  else if ssRight in Shift then begin
    if DrawMode<>drawModeNone then begin
      UpdateDrawTool(x1, y1, SelectionRMB);
    end
    else begin
      if Matrix[fCurrentFrame, x1, y1]=0 then begin
              DrawWithBrush(SelectionRMB, x1, y1);
      end;

      LastX := x1;
      LastY := y1;

      MatrixChange;
    end;
  end;

  PaintBox.Repaint;
end;

procedure TTheMatrix.Shape1MouseMoveBiColour(Sender: TObject; Shift: TShiftState; X, Y: Integer);
 var
  x1, y1, x2, y2 : integer;

 begin
  x1 := Floor(x/MatrixPixelSize);
  y1 := Floor(y/MatrixPixelSize);

  if (x1<0) or (y1<0) then exit;  

  // ===========================================================================

  if Assigned(FOnMouseOver) then
    FOnMouseOver(x1, y1);

  // ===========================================================================
  // ===========================================================================

  if ssRight in Shift then begin
    if ((LastX=x1) and (LastY=y1)) then exit;

    if (MatrixGradient = 1) and (MatrixGradientI[y1]<>0) and (SelectionRMB<>0) then begin
      DrawWithBrush(MatrixGradientI[y1], x1, y1);
    end
    else begin
      DrawWithBrush(SelectionRMB, x1, y1);
    end;

    LastX := x1;
    LastY := y1;

    MatrixChange;
  end
  else if ssMiddle in shift then begin
    if ((LastX=x1) and (LastY=y1)) then exit;

    if (MatrixGradient = 1) and (MatrixGradientI[y1]<>0) and (SelectionMMB<>0)  then begin
      DrawWithBrush(MatrixGradientI[y1], x1, y1);
    end
    else begin
      DrawWithBrush(SelectionMMB, x1, y1);
    end;

    LastX := x1;
    LastY := y1;

    MatrixChange;
  end
  else if not((LastX=x1) and (LastY=y1)) then begin
    if MatrixCopyX<>0 then begin

      if (MatrixType>0) then begin

        for x2:=0 to MatrixCopyX do begin
          for y2:=0 to MatrixCopyY do begin
            if (x2+x1>=0) and (x2+x1<=MatrixWidth) and
              (y2+y1>=0) and (y2+y1<=MatrixHeight) then begin

            if MatrixCopy[x2, y2]>0 then
              Matrix[fCurrentFrame, x2+x1, y2+y1] := MatrixCopy[x2, y2]
            else
              if not(ssShift in shift) then
                Matrix[fCurrentFrame, x2+x1, y2+y1] := 0;
            end;
          end;
        end;
      end;
    end;
  end;

  PaintBox.Repaint;
end;

// =============================================================================
// =============================================================================
// =============================================================================

procedure TTheMatrix.BackupMatrix(matrixindex : integer);
 var
  x,y : integer;

 begin
  for y:=0 to MatrixHeight do begin
    for x:=0 to MatrixWidth do begin
      MatrixBackup[x, y]:=Matrix[matrixindex, x, y];
    end;
  end;

  UndoData.mode := 0;
end;

procedure TTheMatrix.ClearCurrentFrame;
 var
  x,y : integer;

 begin
  BackupMatrix(fCurrentFrame);

  for x:=0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      Matrix[fCurrentFrame, x, y] :=0;
    end;
  end;

  PaintBox.Repaint;

  MatrixChange;
end;

procedure TTheMatrix.ClearFrame(frame : integer);
 var
  x,y : integer;

 begin
  for x:=0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      Matrix[frame, x, y] :=0;
    end;
  end;

  PaintBox.Repaint;
end;

procedure TTheMatrix.PerformEffectOnCurrentFrame(mode : integer);
 var
  x,y : integer;

 begin
  BackupMatrix(fCurrentFrame);

  case mode of
    modeFlip      : begin
                      for x:=0 to MatrixWidth do begin
                        for y:=0 to MatrixHeight do begin
                          Matrix[fCurrentFrame, x, y] := MatrixBackup[MatrixWidth-x, y];
                        end;
                      end;
                    end;
    modeMirror    : begin
                      for y:=0 to MatrixHeight do begin
                        for x:=0 to MatrixWidth do begin
                          Matrix[fCurrentFrame, x, y] := MatrixBackup[x, MatrixHeight-y];
                        end;
                      end;
                    end;
    modeInvert    : begin
                      for x:=0 to MatrixWidth do begin
                        for y:=0 to MatrixHeight do begin
                          if MatrixType = 0 then
                            Matrix[fCurrentFrame, x, y]:=1-Matrix[fCurrentFrame, x, y]
                          else
                            Matrix[fCurrentFrame, x, y]:=3-Matrix[fCurrentFrame, x, y]
                        end;
                      end;
                    end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.PerformEffectOnAllFrames(mode : integer);
 var
  x,y, slot : integer;

 begin
  case mode of
    modeFlip        : begin
                        for slot:=1 to _MaxAnimBufferFrame do begin
                          BackupMatrix(slot);

                          for x:=0 to MatrixWidth do begin
                            for y:=0 to MatrixHeight do begin
                              Matrix[slot, x, y] := MatrixBackup[MatrixWidth-x, y];
                            end;
                          end;
                        end;
                      end;
    modeMirror      : begin
                        for slot:=1 to _MaxAnimBufferFrame do begin
                          BackupMatrix(slot);

                          for y:=0 to MatrixHeight do begin
                            for x:=0 to MatrixWidth do begin
                              Matrix[slot, x, y] := MatrixBackup[x, MatrixHeight-y];
                            end;
                          end;
                        end;
                      end;
    modeInvert      : begin
                        for slot:=1 to _MaxAnimBufferFrame do begin
                          BackupMatrix(slot);

                          for x:=0 to MatrixWidth do begin
                            for y:=0 to MatrixHeight do begin
                              if MatrixType = 0 then
                                Matrix[slot, x, y]:=1 - MatrixBackup[x, y]
                              else
                                Matrix[slot, x, y]:=3 - MatrixBackup[x, y];
                            end;
                          end;
                        end;
                      end;
    modeGradientAll : begin
                        for slot:=1 to _MaxAnimBufferFrame do begin
                          for x:=0 to MatrixWidth do begin
                            for y:=0 to MatrixHeight do begin
                              if (MatrixGradient = 1) and (MatrixGradientI[y]<>0) then begin
                                if Matrix[slot, x, y]<>0 then
                                  Matrix[slot, x, y]:=MatrixGradientI[y];
                              end;
                            end;
                          end;
                        end;
                      end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.PerformScrollOnCurrentFrame(mode : integer);
 var
  x,y : integer;

 begin
  BackupMatrix(fCurrentFrame);

  case mode of
     modeScrollLeft  : begin
                         for x:=0 to MatrixWidth-1 do begin
                           for y:=0 to MatrixHeight do begin
                             Matrix[fCurrentFrame, x, y] := MatrixBackup[x+1, y];
                           end;
                         end;

                         for y:=0 to MatrixHeight do begin
                           Matrix[fCurrentFrame, MatrixWidth, y] := MatrixBackup[0, y];
                         end;
                       end;
     modeScrollRight : begin
                         for x:=1 to MatrixWidth do begin
                           for y:=0 to MatrixHeight do begin
                             Matrix[fCurrentFrame, x, y] := MatrixBackup[x-1, y];
                           end;
                         end;

                         for y:=0 to MatrixHeight do begin
                           Matrix[fCurrentFrame, 0, y] := MatrixBackup[MatrixWidth, y];
                         end;
                       end;
     modeScrollUp    : begin
                         for y:=0 to MatrixHeight-1 do begin
                           for x:=0 to MatrixWidth do begin
                             Matrix[fCurrentFrame, x, y] := MatrixBackup[x, y+1];
                           end;
                         end;

                         for x:=0 to MatrixWidth do begin
                           Matrix[fCurrentFrame, x, MatrixHeight] := MatrixBackup[x, 0];
                         end;
                       end;
     modeScrollDown  : begin
                         for y:=1 to MatrixHeight do begin
                           for x:=0 to MatrixWidth do begin
                             Matrix[fCurrentFrame, x, y] := MatrixBackup[x, y-1];
                           end;
                         end;

                         for x:=0 to MatrixWidth do begin
                           Matrix[fCurrentFrame, x, 0] := MatrixBackup[x, MatrixHeight];
                         end;
                       end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.RotateCurrentFrame(mode : integer);
 var
  x,y : integer;

 begin
  BackupMatrix(fCurrentFrame);

  case mode of
    modeRotateCW  : begin
                      for x:=0 to MatrixWidth do begin
                        for y:=0 to MatrixHeight do begin
                          Matrix[fCurrentFrame, x, y] := MatrixBackup[y, MatrixWidth-x];
                        end;
                      end;
                    end;
    modeRotateACW : begin
                      for x:=0 to MatrixWidth do begin
                        for y:=0 to MatrixHeight do begin
                          Matrix[fCurrentFrame, x, y] := MatrixBackup[MatrixHeight-y, x];
                        end;
                      end;
                    end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.RotateFrame(newangle : real; toframe : integer);
 var
  newx, newy, x, y, ox, oy, hx, hy: integer;
  myangle : real;

 begin
  ClearFrame(toframe);

  myangle :=(pi*newangle)/180;
  hx      :=Round(MatrixWidth/2);
  hy      :=Round(MatrixHeight/2);

  for x:=0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      if MatrixBackup[x, y]>0 then begin
        ox:=x-hx;
        oy:=y-hy;

        newx:=hx+Round((ox * cos(myangle)) - (oy * sin(myangle)));
        newy:=hy+Round((ox * sin(myangle)) + (oy * cos(myangle)));

        if ((newx>=0) and (newx<=MatrixWidth) and (newy>=0) and (newy<=MatrixHeight)) then
          Matrix[toframe, newx, newy] := MatrixBackup[x, y];
      end;
    end;
  end;

  MatrixChange;
end;

// =============================================================================

procedure TTheMatrix.ChangeCurrentFrame(frame : integer);
 begin
  fCurrentFrame := frame;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.ChangeLightBox(lb : integer);
 begin
  fLightBox := lb;

  PaintBox.Repaint;
end;

procedure TTheMatrix.ChangeGrid(grid : boolean);
 begin
  MatrixGrid:=grid;

 if MatrixGrid then
    MatrixPixelSizeZ := MatrixPixelSize-1
  else
    MatrixPixelSizeZ := MatrixPixelSize;
end;

// =============================================================================

procedure TTheMatrix.CopyCurrentFrame;
 var
  x,y : integer;

 begin
  for y:=0 to MatrixHeight do begin
    for x:=0 to MatrixWidth do begin
      MatrixCopy[x, y] := Matrix[fCurrentFrame, x, y];
    end;
  end;
end;

procedure TTheMatrix.InsertBlankFrameAt(frameinsert, maxframes : integer);
 var
  x, y, slot : integer;

 begin
  if frameinsert<>maxframes then begin
    for slot:=maxframes downto frameinsert+1 do begin
      for x:=0 to MatrixWidth do begin
        for y:=0 to MatrixHeight do begin
           Matrix[slot, x, y] := Matrix[slot-1, x, y];
        end;
      end;
    end;
  end;

  for x:=0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      Matrix[frameinsert+1, x, y] :=0;
    end;
  end;
end;

procedure TTheMatrix.InsertCopyFrameAt(frameinsert, maxframes : integer);
 var
  x, y, slot : integer;

 begin
  if frameinsert<>maxframes then begin
    for slot:=maxframes downto frameinsert+1 do begin
      for x:=0 to MatrixWidth do begin
        for y:=0 to MatrixHeight do begin
           Matrix[slot, x, y] := Matrix[slot-1, x, y];
        end;
      end;
    end;
  end;

  //for x:=0 to MatrixWidth do begin
//    for y:=0 to MatrixHeight do begin
//      Matrix[frameinsert+1, x, y] := Matrix[frameinsert, x, y];
//    end;
//  end;
end;

procedure TTheMatrix.AddFrameMultiple(framecount, framecurrent, framemax : integer);
 var
  oldframe, slot : integer;

 begin
  oldframe := framecurrent;

  for slot:=1 to framecount do begin
    InsertBlankFrameAt(oldframe, framemax);

    inc(oldframe);
    inc(framemax);
  end;
end;

procedure TTheMatrix.CopyShape;
 var
  x,y, tc : integer;

 begin
  for x:=0 to _MaxWidth do begin
    for y:=0 to _MaxHeight do begin
      MatrixCopy[x, y]:=0;
    end;
  end;

  if (DrawCoords[0].X>DrawCoords[1].X) then begin
    tc:=DrawCoords[0].X;

    DrawCoords[0].X :=DrawCoords[1].X;
    DrawCoords[1].X :=tc;
  end;

  if (DrawCoords[0].Y>DrawCoords[1].Y) then begin
    tc:=DrawCoords[0].Y;

    DrawCoords[0].Y :=DrawCoords[1].Y;
    DrawCoords[1].Y :=tc;
  end;

  MatrixCopyX:=DrawCoords[1].X-DrawCoords[0].X;
  MatrixCopyY:=DrawCoords[1].Y-DrawCoords[0].Y;  

  for x:=DrawCoords[0].X to DrawCoords[1].X do begin
    for y:=DrawCoords[0].Y to DrawCoords[1].Y do begin
      MatrixCopy[x-DrawCoords[0].X, y-DrawCoords[0].Y]:=Matrix[fCurrentFrame, x, y];
    end;
  end;

  DrawPoint       :=0;
  DrawMode        :=drawModePaste;
  DrawCoords[0].X := -1;
  DrawCoords[0].Y := -1;
end;

procedure TTheMatrix.UpdateDrawTool(setx, sety, setcolour : integer);
 begin
  DrawCoords[DrawPoint].X:= setx;
  DrawCoords[DrawPoint].Y:= sety;

  if DrawPoint = 0 then
    DrawColour:=setcolour;

  BackupMatrix(fCurrentFrame);

  case DrawMode of
    drawModeFilledBox,
    drawModeEmptyBox,
    drawModeLine,
    drawModeEmptyCircle : begin
                            inc(DrawPoint);

                            if DrawPoint=2  then
                              DrawShape(False, DrawColour);
                            end;
    drawModeCopy        : begin
                           inc(DrawPoint);

                           if DrawPoint=2  then
                             CopyShape;
                           end;
  end;
end;

procedure TTheMatrix.DrawShape(realtime : boolean; colour : integer);
 var
  x,y, tc     : integer;
  a,b         : integer;  // displacements in x and y
  d           : integer;  // decision variable
  diag_inc    : integer;  // d's increment for diagonal steps
  dx_diag     : integer;  // diagonal x step for next pixel
  dx_nondiag  : integer;  // nondiagonal x step for next pixel
  dy_diag     : integer;  // diagonal y step for next pixel
  dy_nondiag  : integer;  // nondiagonal y step for next pixel
  i           : integer;  // loop index
  nondiag_inc : integer;  // d's increment for nondiagonal steps
  x1,y1,x2,y2 : integer;

 begin
  if not(realtime) then
    BackupMatrix(fCurrentFrame)
  else begin
    DrawCoords[1].X:=lastx;
    DrawCoords[1].Y:=lasty;
  end;

  x1 := DrawCoords[0].X;
  y1 := DrawCoords[0].Y;
  x2 := DrawCoords[1].X;
  y2 := DrawCoords[1].Y;

  // ===========================================================================

  case DrawMode of
    // =========================================================================
    // == Filled Box ===========================================================
    // =========================================================================
    drawModeFilledBox   : begin
                            if (x1>x2) then begin
                              tc:=x1;
                              x1:=x2;
                              x2:=tc;
                            end;

                            if (y1>y2) then begin
                              tc:=y1;
                              y1:=y2;
                              y2:=tc;
                            end;

                            for x:=x1 to x2 do begin
                              for y:=y1 to y2 do begin
                                if realtime then begin
                                  case MatrixPixelShape of
                                    0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                     (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
                                    1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                                               (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
                                  end;
                                end
                                else
                                  Matrix[fCurrentFrame, x, y] :=colour
                              end;
                            end;
                          end;
    // =========================================================================
    // == Empty Box ============================================================
    // =========================================================================
    drawModeEmptyBox    : begin
                            if (x1>x2) then begin
                              tc:=x1;
                              x1:=x2;
                              x2:=tc;
                            end;

                            if (y1>y2) then begin
                              tc:=y1;

                              y1:=y2;
                              y2:=tc;
                            end;

                            for x:=x1 to x2 do begin
                              for y:=y1 to y2 do begin
                                if ((x=x1) or (x=x2)) or ((y=y1) or (y=y2))  then begin

                                  if realtime then begin
                                    case MatrixPixelShape of
                                      0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                       (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
                                      1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                 (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
                                    end;
                                  end
                                  else
                                    Matrix[fCurrentFrame, x, y] :=colour
                                end;
                              end;
                            end;
                          end;
    // =========================================================================
    // == Straight Line ========================================================
    // =========================================================================
    drawModeLine        : begin
                            x := x1;              // line starting point
                            y := y1;

                            // Determine drawing direction and step to the next pixel.
                            a := x2 - x1;       // difference in x dimension
                            b := y2 - y1;       // difference in y dimension

                            // Determine whether end point lies to right or left of start point.
                            if   a < 0  then begin
                              a := -a;                // make 'a' positive
                              dx_diag := -1
                            end
                            else
                              dx_diag := 1;

                            // Determine whether end point lies above or below start point.
                            if   b < 0 then begin
                              b := -b;                // make 'a' positive
                              dy_diag := -1
                            end
                            else
                              dy_diag := 1;

                            // Identify octant containing end point.
                            if   a < b then begin
                              tc := a;
                              a := b;
                              b := tc;
                              dx_nondiag := 0;
                              dy_nondiag := dy_diag
                            end
                            else begin
                              dx_nondiag := dx_diag;
                              dy_nondiag := 0
                            end;

                            d := b + b - a;            // initial value for d is 2*b - a
                            nondiag_inc := b + b;      // set initial d increment values
                            diag_inc    := b + b - a - a;

                            for i := 0 to a do begin   // draw the a+1 pixels

                              if realtime then begin
                                case MatrixPixelShape of
                                  0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                   (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
                                  1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                                             (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
                                end;
                               end
                               else
                                 Matrix[fCurrentFrame, x, y] :=colour;

                              if d < 0 then begin               // step nondiagonally
                                x := x + dx_nondiag;
                                y := y + dy_nondiag;
                                d := d + nondiag_inc   // update decision variable
                              end
                              else begin               // midpoint is above the line; step diagonally
                                x := x + dx_diag;
                                y := y + dy_diag;
                                d := d + diag_inc
                              end
                            end
                          end;
    // =========================================================================
    // == Empty Circle =========================================================
    // =========================================================================
    drawModeEmptyCircle : begin
                            // c^2 = a^2 + b^2
                            tc:=round(sqrt(sqr(abs(x1-x2))+sqr(abs(y1-y2)))); // radius of circle

                            // midpoint algorithm: http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
                            a:=0;
                            b:=1-tc;
                            while(tc >= a) do begin
                              if realtime then begin
                                case MatrixPixelShape of
                                  0 : begin
                                        PaintBox.Canvas.FillRect(Rect( (tc + x1)*MatrixPixelSize,   (a + y1)*MatrixPixelSize,  ((tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,   ((a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect(  (a + x1)*MatrixPixelSize,  (tc + y1)*MatrixPixelSize,   ((a + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect((-tc + x1)*MatrixPixelSize,   (a + y1)*MatrixPixelSize, ((-tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,   ((a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect( (-a + x1)*MatrixPixelSize,  (tc + y1)*MatrixPixelSize,  ((-a + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect((-tc + x1)*MatrixPixelSize,  (-a + y1)*MatrixPixelSize, ((-tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((-a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect( (-a + x1)*MatrixPixelSize, (-tc + y1)*MatrixPixelSize,  ((-a + x1)*MatrixPixelSize)+MatrixPixelSizeZ, ((-tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect( (tc + x1)*MatrixPixelSize,  (-a + y1)*MatrixPixelSize,  ((tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((-a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.FillRect(Rect(  (a + x1)*MatrixPixelSize, (-tc + y1)*MatrixPixelSize,   ((a + x1)*MatrixPixelSize)+MatrixPixelSizeZ, ((-tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                      end;
                                  1 : begin
                                        PaintBox.Canvas.Ellipse(Rect( (tc + x1)*MatrixPixelSize,   (a + y1)*MatrixPixelSize,  ((tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,   ((a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect(  (a + x1)*MatrixPixelSize,  (tc + y1)*MatrixPixelSize,   ((a + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect((-tc + x1)*MatrixPixelSize,   (a + y1)*MatrixPixelSize, ((-tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,   ((a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect( (-a + x1)*MatrixPixelSize,  (tc + y1)*MatrixPixelSize,  ((-a + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect((-tc + x1)*MatrixPixelSize,  (-a + y1)*MatrixPixelSize, ((-tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((-a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect( (-a + x1)*MatrixPixelSize, (-tc + y1)*MatrixPixelSize,  ((-a + x1)*MatrixPixelSize)+MatrixPixelSizeZ, ((-tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect( (tc + x1)*MatrixPixelSize,  (-a + y1)*MatrixPixelSize,  ((tc + x1)*MatrixPixelSize)+MatrixPixelSizeZ,  ((-a + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                        PaintBox.Canvas.Ellipse(Rect(  (a + x1)*MatrixPixelSize, (-tc + y1)*MatrixPixelSize,   ((a + x1)*MatrixPixelSize)+MatrixPixelSizeZ, ((-tc + y1)*MatrixPixelSize)+MatrixPixelSizeZ));
                                      end;
                                end;
                              end
                              else begin
                                Matrix[fCurrentFrame,  tc + x1,   a + y1] := colour;
                                Matrix[fCurrentFrame,   a + x1,  tc + y1] := colour;
                                Matrix[fCurrentFrame, -tc + x1,   a + y1] := colour;
                                Matrix[fCurrentFrame,  -a + x1,  tc + y1] := colour;
                                Matrix[fCurrentFrame, -tc + x1,  -a + y1] := colour;
                                Matrix[fCurrentFrame,  -a + x1, -tc + y1] := colour;
                                Matrix[fCurrentFrame,  tc + x1,  -a + y1] := colour;
                                Matrix[fCurrentFrame,   a + x1, -tc + y1] := colour;
                              end;

                              inc(a);

                              if (b<0) then
                                b := b+ 2 * a + 1
                              else begin
                                dec(tc);
                                b := b+ 2 * (a - tc + 1);
                              end;
                            end;

                            { Old algorithm, not as good
                            for d:=1 to 512 do begin                          // higher number = more accurate circle at larger matrix sizes  (512 is good for 64x64)
                              x := Round(x1 + (tc*Cos(((2*pi)*d)/512)));
                              y := Round(y1 - (tc*Sin(((2*pi)*d)/512)));

                              if realtime then begin
                                case MatrixPixelShape of
                                  0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                   (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
                                  1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                                             (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
                                end;
                              end
                              else
                                Matrix[fCurrentFrame, x, y] :=1;
                            end;}
                          end;
    // =========================================================================
    // == Copy Lasso thing =====================================================
    // =========================================================================
    drawModeCopy    : begin
                        if not(realtime) then exit;

                        if (x1>x2) then begin
                          tc:=x1;
                          x1:=x2;
                          x2:=tc;
                         end;

                         if (y1>y2) then begin
                           tc:=y1;

                           y1:=y2;
                           y2:=tc;
                         end;

                         PaintBox.Canvas.Brush.Color := LEDColours[4];

                         for x:=x1 to x2 do begin
                           for y:=y1 to y2 do begin
                             if (((x=x1) or (x=x2)) or ((y=y1) or (y=y2))) then begin
                               case MatrixPixelShape of
                                 0 : PaintBox.Canvas.FillRect(Rect(x*MatrixPixelSize, y*MatrixPixelSize,
                                                                  (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ));
                                 1 : PaintBox.Canvas.Ellipse(x*MatrixPixelSize, y*MatrixPixelSize,
                                                            (x*MatrixPixelSize)+MatrixPixelSizeZ, (y*MatrixPixelSize)+MatrixPixelSizeZ);
                               end;
                             end;
                           end;
                         end;
                       end;
  end;

  if not(realtime) then begin
    MatrixChange;

    DrawPoint :=0;
    DrawCoords[0].X := -1;
    DrawCoords[0].Y := -1;

    PaintBox.Repaint;
  end;
end;

procedure TTheMatrix.DrawFontCharacter(asciicode, frameid : integer);
 var
  t,xbyte,b,zig,startY,y : integer;
  ts : string;

 begin
  startY := DrawCoords[0].Y;

  ts:='';
  for t:=1 to length(LEDFont[asciicode]) do begin
    if LEDFont[asciicode][t]=' ' then begin
      if ts<>'' then begin
        xbyte:=StrToInt(ts);
        ts:='';

        y:=startY;

        for b:=0 to 7 do begin
          zig:=xbyte and powers[b];

          if zig = powers[b] then begin
            if (DrawCoords[0].X>=0) and (DrawCoords[0].X<=MatrixWidth) and
               (y>=0) and (y<=MatrixHeight) then begin

              Matrix[frameid, DrawCoords[0].X, y] := DrawColour;
            end;
          end;

          dec(y);
        end;

        inc(DrawCoords[0].X);
      end;
    end
    else
      ts:=ts+LEDFont[asciicode][t];
  end;

  inc(DrawCoords[0].X); // adds single column spacing between chars

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.DeleteFontCharacter(frameid : integer);
 var
  y : integer;

 begin
  dec(DrawCoords[0].X);

  for y:=DrawCoords[0].Y downto DrawCoords[0].Y-7 do begin
    if (DrawCoords[0].X>=0) and (DrawCoords[0].X<=MatrixWidth) and
       (y>=0) and (y<=MatrixHeight) then begin

      Matrix[frameid, DrawCoords[0].X, y] :=0;
    end;
  end;

  MatrixChange;

  PaintBox.Repaint;  
end;

procedure TTheMatrix.LoadFont(filename : string);
 var
  tf : TextFile;
  s,temp : string;
  t,i : integer;

 begin
  AssignFile(tf, filename);
  Reset(tf);

  i:=0;

  while not(eof(tf)) do begin
    Readln(tf, s);

    if s[1]<>'/' then begin
      temp:='';

      t:=1;

      while (s[t]<>'/') and (t<=length(s)) do begin
        if (ord(s[t])=32) or ((ord(s[t])>=48) and (ord(s[t])<=57)) then
          temp:=temp+s[t];

        inc(t);
      end;

      LEDFont[i]:=temp;
      inc(i);
    end;
  end;

  LEDFontSize:=i-1;

  CloseFile(tf);
end;

// =============================================================================

procedure TTheMatrix.DeleteFrame(frame, framemax : integer);
 var
  x,y,t : integer;

 begin
  for t:=frame to framemax-1 do begin
    for y := 0 to MatrixHeight do begin
      for x:=0 to MatrixWidth do begin
        Matrix[t, x, y]:=Matrix[t+1, x, y];
      end;
    end;
  end;

  if frame = framemax then
    fCurrentFrame := frame-1;

  MatrixChange;

  PaintBox.Repaint;
end;

// =============================================================================
// =============================================================================
// == Saving / Loading =========================================================
// =============================================================================
// =============================================================================

procedure TTheMatrix.ImportRowData(imhex : boolean; sourcedirection, sourcelsb : integer; s : string);
 var
  t, x, rowindex : integer;
  zig, rowvalue : int64;
  temp : string;

 begin
  if sourcedirection = 0 then
    rowindex :=0
  else
    rowindex :=MatrixHeight;

  temp     :='';

  s:=UpperCase(s);
  s:=StringReplace(s, '0X', '$', [rfReplaceAll]);
  s:=StringReplace(s, ',', ' ', [rfReplaceAll]);
  s:=StringReplace(s, '[', '', [rfReplaceAll]);
  s:=StringReplace(s, ']', '', [rfReplaceAll]);
  s:=StringReplace(s, '{', '', [rfReplaceAll]);
  s:=StringReplace(s, '}', '', [rfReplaceAll]);
  s:=StringReplace(s, '(', '', [rfReplaceAll]);
  s:=StringReplace(s, ')', '', [rfReplaceAll]);
  s:=s+' ';

  for t:=1 to length(s) do begin
    if s[t]=' ' then begin
      if temp<>'' then begin

        if imhex then
          rowvalue:=StrToInt64('$'+temp)
        else
          rowvalue:=StrToInt64(temp);

        if (rowindex>=0) and (rowindex<=MatrixHeight) then begin
          for x:=0 to MatrixWidth do begin
            case sourcelsb of
              0 : begin
                    zig:=(rowvalue and Powers[x]);

                    if zig = Powers[x] then begin
                      Matrix[fCurrentFrame, x, rowindex]:=1;
                    end
                    else begin
                      Matrix[fCurrentFrame, x, rowindex]:=0;
                    end;
                  end;
              1 : begin
                    zig:=(rowvalue and Powers[x]);

                    if zig = Powers[x] then begin
                      Matrix[fCurrentFrame, MatrixWidth-x, rowindex]:=1;
                    end
                    else begin
                      Matrix[fCurrentFrame, MatrixWidth-x, rowindex]:=0;
                    end;
                  end;
            end;
          end;
        end;

        temp:='';

        if sourcedirection = 0 then
          inc(rowindex)
        else
          dec(rowindex);
      end;
    end
    else if (ord(s[t])>=48) and (ord(s[t])<=57) then begin
      temp:=temp+s[t];
    end
    else if (ord(s[t])>=65) and (ord(s[t])<=90) then begin
      temp:=temp+s[t];
    end
    else if (s[t]='$') then begin
      imhex:=True;
    end;

    MatrixChange;
  end;

  PaintBox.Repaint;
end;

procedure TTheMatrix.ImportColumnData(imhex : boolean; sourcedirection, sourcelsb : integer; s : string);
 var
  t, y, colindex  : integer;
  zig, colvalue : int64;
  temp : string;

 begin
  if sourcedirection = 0 then
    colindex := 0
  else
    colindex := MatrixWidth;

  temp:='';

  s:=UpperCase(s);
  s:=StringReplace(s, '0X', '$', [rfReplaceAll]);
  s:=StringReplace(s, ',', ' ', [rfReplaceAll]);
  s:=StringReplace(s, '[', '', [rfReplaceAll]);
  s:=StringReplace(s, ']', '', [rfReplaceAll]);
  s:=StringReplace(s, '{', '', [rfReplaceAll]);
  s:=StringReplace(s, '}', '', [rfReplaceAll]);
  s:=StringReplace(s, '(', '', [rfReplaceAll]);
  s:=StringReplace(s, ')', '', [rfReplaceAll]);
  s:=s+' ';

  for t:=1 to length(s) do begin
    if s[t]=' ' then begin
      if temp<>'' then begin

        if imhex then
          colvalue:=StrToInt64('$'+temp)
        else
          colvalue:=StrToInt64(temp);

        if (colindex>=0) and (colindex<=MatrixWidth) then begin
          for y:=0 to MatrixHeight do begin
            case sourcelsb of
              0 : begin
                    zig:=(colvalue and Powers[y]);

                   if zig = Powers[y] then begin
                      Matrix[fCurrentFrame, colindex, y]:=1;
                    end
                    else begin
                      Matrix[fCurrentFrame, colindex, y]:=0;
                    end;
                  end;
              1 : begin
                    zig:=(colvalue and Powers[y]);

                    if zig = Powers[y] then begin
                      Matrix[fCurrentFrame, colindex, MatrixHeight-y]:=1;
                    end
                    else begin
                      Matrix[fCurrentFrame, colindex, MatrixHeight-y]:=0;
                    end;
                  end;
            end;
          end;
        end;

        temp:='';

        if sourcedirection = 0 then
          inc(colindex)
        else
          dec(colindex);
      end;
    end
    else if (ord(s[t])>=48) and (ord(s[t])<=57) then begin
      temp:=temp+s[t];
    end
    else if (ord(s[t])>=65) and (ord(s[t])<=90) then begin
      temp:=temp+s[t];
    end
    else if (s[t]='$') then begin
      imhex:=True;
    end;

    MatrixChange;
  end;

  PaintBox.Repaint;  
end;

function TTheMatrix.LoadDataParameterType(s : string): integer;
  begin
   if Pos('header', s)<>0 then
     Result:=99
   else if s[1]='{' then
     Result:=0
   else if s[1]='}' then
     Result:=1
   else if s[1]='w' then
     Result:=2
   else if s[1]='h' then
     Result:=3
   else if s[1]='r' then
     Result:=4
   else if s[1]='a' then
     Result:=5
   else if s[1]='b' then
     Result:=6
   else if s[1]='c' then
     Result:=7
   else if s[1]='d' then
     Result:=8
   else if s[1]='1' then
     Result:=9
   else if s[1]='2' then
     Result:=10
   else if s[1]='3' then
     Result:=11
   else if s[1]='4' then
     Result:=12
   else if s[1]='i' then          // ascii index
     Result:=20
   else if s[1]='x' then          // matrix comment
     Result:=30
   else
     Result:=-1;
 end;

function TTheMatrix.ImportLEDMatrixDataSingleFrame(fn : string): TImportData;
 var
  tf : TextFile;
  x,iv,Row,MemSlot,i,matrixtype : integer;
  s,v : string;
  addedSingleFrame, headerMode : boolean;

 begin
  BackupMatrix(fCurrentFrame);
  addedSingleFrame :=False;
  matrixtype       :=0;

  Result.Source          :=-1;
  Result.SourceLSB       :=-1;
  Result.SourceDirection :=-1;
  Result.MatrixType      :=-1;

  // ===========================================================================
  // ===========================================================================

  AssignFile(tf, fn);
  Reset(tf);

  MemSlot    :=fCurrentFrame;
  Row        :=0;
  headerMode :=False;

  while not(eof(tf)) and (addedSingleFrame=False) do begin
    readln(tf, s);

    if s<>'' then begin
      v:=Copy(s, 3, length(s)-2);
      iv:=StrToInt(v);

      case LoadDataParameterType(s) of
        0 : begin
              Row:=0;

              case s[length(s)] of
                '2' : matrixtype := 1;
                '3' : matrixtype := 2;
              else
                matrixtype := 0;
              end;

              headerMode:=False;
            end;
        1 : begin
              if headerMode=False then
                addedSingleFrame:=True;
            end;
        2 : begin
            end;
        3 : begin
            end;
        4 : begin
              x:=0;

              for i:=1 to length(v) do begin
                if (v[i]<>' ') then begin
                  Matrix[MemSlot, x, Row]:=StrToInt(v[i]);

                  inc(x);
                end;
              end;

              inc(Row);
            end;
          5 : begin
                Result.Source:=iv;
              end;
          6 : begin
                Result.SourceLSB:=iv;
              end;
          7 : begin
                Result.SourceDirection:=iv;
              end;
          8 : {};
         30 : MatrixComment:=v;
         99 : begin
                headerMode:=True;
              end;
      end;
    end;
  end;

  CloseFile(tf);

  Result.MatrixType:=matrixtype;

  MatrixChange;

  PaintBox.Repaint;
end;

function TTheMatrix.ImportFromBMP(fn : string; fcount, fwidth, fheight : integer): TImportData;
 var
  ibmp : TBitmap;
  i, w, h, wo : integer;

 begin
  ibmp:=TBitmap.Create;
  ibmp.LoadFromFile(fn);

  // ===========================================================================

  for i:=1 to fcount do begin
    wo:=(i-1) * fwidth;

    for w:=0 to fwidth-1 do begin

      for h:=0 to fheight-1 do begin
        if ibmp.Canvas.Pixels[wo + w, h]=clWhite then
          Matrix[i, w, h] :=0
        else
          Matrix[i, w, h] :=1;
      end;

    end;
  end;

  // ===========================================================================

  Result.NewWidth    := fwidth-1;
  Result.NewHeight   := fheight-1;
  Result.NewFrames   := fcount;

  PaintBox.Repaint;

  MatrixChange;

  // ===========================================================================

  ibmp.Free;
end;

procedure TTheMatrix.SaveAnimation(filename : string; ted : TImportData);
 var
  s : string;
  tf : TextFile;
  x,y,i : integer;

 begin
  AssignFile(tf, filename);

  Rewrite(tf);

  // ===========================================================================

  writeln(tf, '{header');
  writeln(tf, 'a: '+IntToStr(ted.Source));
  writeln(tf, 'b: '+IntToStr(ted.SourceLSB));
  writeln(tf, 'c: '+IntToStr(ted.SourceDirection));
  writeln(tf, '1: '+IntToStr(ted.PadMode));
  writeln(tf, '2: '+IntToStr(ted.HexFormat));
  writeln(tf, '3: '+IntToStr(ted.HexOutput));
  writeln(tf, '4: '+IntToStr(ted.Brackets));
  writeln(tf, 'x: '+MatrixComment);
  writeln(tf, '}');

  // ===========================================================================

  for i:=1 to ted.MaxFrames do begin
    case ted.MatrixType of
      0 : writeln(tf, '{anim');
      1 : writeln(tf, '{anim2');
      2 : writeln(tf, '{anim3');
    end;

    writeln(tf, 'w:'+IntToStr(MatrixWidth + 1));
    writeln(tf, 'h:'+IntToStr(MatrixHeight + 1));

    for y:=0 to MatrixHeight do begin
      s:='';

      for x := 0 to MatrixWidth do begin
        s:=s+IntToStr(Matrix[i, x, y])+' ';
      end;

      writeln(tf, 'r:'+s);
    end;

    writeln(tf, '}');
  end;

  // ===========================================================================

  CloseFile(tf);
end;

procedure TTheMatrix.SaveFont(filename : string; ted : TImportData);
 var
  s : string;
  tf : TextFile;
  x,y,i : integer;

 begin
  AssignFile(tf, filename);

  Rewrite(tf);

  // ===========================================================================

  writeln(tf, '{fontheader');
  writeln(tf, 'a: '+IntToStr(ted.Source));
  writeln(tf, 'b: '+IntToStr(ted.SourceLSB));
  writeln(tf, 'c: '+IntToStr(ted.SourceDirection));
  writeln(tf, 'i: '+IntToStr(ted.ASCIIIndex));
  writeln(tf, 'x: '+MatrixComment);
  writeln(tf, '}');

  // ===========================================================================

  for i:=1 to 96 do begin
    case ted.MatrixType of
      0 : writeln(tf, '{font');
      1 : writeln(tf, '{font2');
      2 : writeln(tf, '{font3');
    end;

    writeln(tf, 'w:'+IntToStr(MatrixWidth + 1));
    writeln(tf, 'h:'+IntToStr(MatrixHeight + 1));

    for y:=0 to MatrixHeight do begin
      s:='';

      for x := 0 to MatrixWidth do begin
        s:=s+IntToStr(Matrix[i, x, y])+' ';
      end;

      writeln(tf, 'r:'+s);
    end;

    writeln(tf, '}');
  end;

  // ===========================================================================

  CloseFile(tf);
end;

procedure TTheMatrix.SaveSingleFrame(filename : string; ted : TImportData; frame : integer);
 var
  s : string;
  tf : TextFile;
  x,y : integer;

 begin
  AssignFile(tf, filename);

  Rewrite(tf);

  case ted.MatrixType of
    0 : writeln(tf, '{frame');
    1 : writeln(tf, '{frame2');
    2 : writeln(tf, '{frame3');
  end;

  writeln(tf, 'w:'+IntToStr(MatrixWidth + 1));
  writeln(tf, 'h:'+IntToStr(MatrixHeight + 1));

    for y:=0 to MatrixHeight do begin
      s:='';

      for x := 0 to MatrixWidth do begin
        s:=s+IntToStr(Matrix[frame, x, y])+' ';
      end;

      writeln(tf, 'r:'+s);
    end;

    writeln(tf, '}');

    CloseFile(tf);
end;

procedure TTheMatrix.SaveAsFont(filename : string);
 var
  tf : textfile;
  t, x, y, mydata : integer;
  s : string;

 begin
  AssignFile(tf, filename);
  Rewrite(tf);

  for t:=1 to 96 do begin
    s:='';

    for x:=0 to MatrixWidth do begin
      mydata:=0;

      for y:=0 to MatrixHeight do begin
        if Matrix[t, x, y]=1 then
          mydata:=mydata+(powers[MatrixHeight-y]);
      end;

      if x<>MatrixWidth then
        s:=s+IntToStr(mydata)+', '
      else
        s:=s+IntToStr(mydata);
    end;

    Writeln(tf, s+' // '+Char(32+t));
  end;

  CloseFile(tf);
end;

// =============================================================================
// =============================================================================
// =============================================================================
// =============================================================================
// =============================================================================

function TTheMatrix.LoadLEDMatrixData(fn : widestring): TImportData;
 var
  tf : TextFile;
  x,Row,MemSlot,i,matrixtype : integer;
  tempMaxWidth, tempMaxHeight : integer;
  s,v : string;
  headerMode, fontmode : boolean;

 begin
  if not(FileExists(fn)) then begin
    MessageDlg('File not found!!', mtWarning, [mbOK], 0);
  end
  else begin
    ClearAllFrames;

  // ===========================================================================
  // ===========================================================================

    AssignFile(tf, fn);
    Reset(tf);

    MemSlot                :=1;
    Row                    :=0;
    headerMode             :=False;
    fontmode               :=False;
    matrixtype             :=0;

    Result.Source          :=-1;
    Result.SourceLSB       :=-1;
    Result.SourceDirection :=-1;
    Result.MatrixType      :=-1;

  // ===========================================================================
  // ===========================================================================

    while not(eof(tf)) do begin
      readln(tf, s);

      if s<>'' then begin
        v:=Copy(s, 3, length(s)-2);

        case LoadDataParameterType(LowerCase(s)) of
          0 : begin
                Row:=0;

                case v[length(v)] of
                  '2' : matrixtype := 1;
                  '3' : matrixtype := 2;
                else
                  matrixtype := 0;
                end;

                headerMode:=False;
              end;
          1 : begin
                if headerMode=False then
                  inc(MemSlot);
              end;
          2 : begin
                tempMaxWidth:=StrToInt(v)-1;
              end;
          3 : begin
                tempMaxHeight:=StrToInt(v)-1;
              end;
          4 : begin
                x:=0;

                for i:=1 to length(v) do begin
                  if (v[i]<>' ') then begin
                    Matrix[MemSlot, x, Row]:=StrToInt(v[i]);

                    inc(x);
                  end;
                end;

                inc(Row);
              end;
          5 : begin
                Result.Source:=StrToInt(v);
              end;
          6 : begin
                Result.SourceLSB:=StrToInt(v);
              end;
          7 : begin
                Result.SourceDirection:=StrToInt(v);
              end;
          8 : {};
          9 : Result.PadMode    :=StrToInt(v);
         10 : Result.HexFormat  :=StrToInt(v);
         11 : Result.HexOutput  :=StrToInt(v);
         12 : Result.Brackets   :=StrToInt(v);
         20 : Result.ASCIIIndex :=StrToInt(v);
         30 : MatrixComment     :=v;
         99 : begin
                if UpperCase(s)='{FONTHEADER' then
                  fontmode:=True
                else
                  fontmode:=False;

                headerMode:=True;
              end;
        end;
      end;
    end;

    CloseFile(tf);

    Result.MatrixType :=matrixtype;
    Result.NewWidth   :=tempMaxWidth;
    Result.NewHeight  :=tempMaxHeight;
    Result.MaxFrames  :=MemSlot-1;
    Result.FontMode   :=fontmode;
  end;
end;

// =============================================================================
// =============================================================================
// =============================================================================
// =============================================================================
// =============================================================================

procedure TTheMatrix.LoadGradient(filename : string);
 var
  tf : TextFile;
  s,v : string;
  t, idx, x, y, slot : integer;

 function parameterType(s : string): integer;
  begin
   if s[1]='{' then
     Result:=0
   else if s[1]='}' then
     Result:=1
   else if s[1]='g' then
     Result:=2
   else
     Result:=-1;
 end;

 begin
  // ===========================================================================

  AssignFile(tf, filename);
  Reset(tf);

  while not(eof(tf)) do begin
    readln(tf, s);

    if s<>'' then begin
      v:=Copy(s, 3, length(s)-2);

      case parameterType(s) of
        2 : begin
              idx:=0;

              for t:=1 to length(v) do begin
                if v[t]<>' ' then begin
                  MatrixGradientI[idx]            :=StrToInt(v[t]);

                  inc(idx);
                end;
              end;

            end;
      end;
    end;
  end;

  CloseFile(tf);

  // ===========================================================================

  for slot:=1 to _MaxAnimBufferFrame {tbFrames.Max} do begin
    for x:=0 to MatrixWidth do begin
      for y:=0 to MatrixHeight do begin
        if Matrix[slot, x, y]<>0 then
          Matrix[slot, x, y] := MatrixGradientI[y];
      end;
    end;
  end;

  // ===========================================================================

  PaintBox.Repaint;
end;

// =============================================================================
// =============================================================================
// =============================================================================

procedure TTheMatrix.CopyToUserBuffer(slot : integer);
 var
  x,y : integer;

 begin
  for y := 0 to MatrixHeight do begin
    for x:=0 to MatrixWidth do begin
      Matrix[_MaxAnimBufferFrame+slot, x, y]:=Matrix[fCurrentFrame, x, y];
    end;
  end;
end;

procedure TTheMatrix.RestoreFromUserBuffer(slot : integer);
 var
  x,y : integer;

 begin
  for x := 0 to MatrixWidth do begin
    for y:=0 to MatrixHeight do begin
      if Matrix[_MaxAnimBufferFrame+slot, x, y] = 1 then begin
        Matrix[fCurrentFrame, x, y] := 1;
      end
      else begin
        Matrix[fCurrentFrame, x, y] := 0;
      end;
    end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.CopyFromPrevious(toframe : integer);
 var
  x,y : integer;

 begin
  BackupMatrix(toframe);

  for y:=0 to MatrixHeight do begin
    for x:=0 to MatrixWidth do begin
      Matrix[toframe, x, y] := Matrix[toframe-1, x, y];
    end;
  end;

  MatrixChange;

  PaintBox.Repaint;
end;

procedure TTheMatrix.Undo;
 var
  x, y : integer;

 begin
  case (UndoData.mode) of
    0 : begin
          for x:=0 to MatrixWidth do begin
            for y:=0 to MatrixHeight do begin
              if MatrixBackup[x, y] = 1 then begin
                Matrix[fCurrentFrame, x, y] :=1;
              end
              else begin
                Matrix[fCurrentFrame, x, y] :=0;
              end;
            end;
          end;
        end;
    1 : begin
          {tbFrames.Position:=UndoData.param1+1;
          tbFramesChange(nil);

          for i:=0 to UndoData.param2-1 do begin
            bDeleteFrameClick(Nil);
          end;     }
        end;
  end;

  UndoData.mode:=-1;

  MatrixChange;

  PaintBox.Repaint;
end;

end.